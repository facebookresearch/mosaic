# Copyright (c) Facebook, Inc. and its affiliates.
# All rights reserved.
#
# This source code is licensed under the BSD-style license found in the
# LICENSE file in the root directory of this source tree.

# pyre-strict

import os
import tempfile

import importlib_resources
from later.unittest import TestCase
from mosaic.cmd.entry_point import (
    get_memory_profile,
    get_memory_usage,
    get_memory_usage_by_annotation_stage,
    get_memory_usage_diff,
    get_memory_usage_peak,
)
from mosaic.libmosaic.analyzer.memory_abstract import MemoryAbstract
from mosaic.libmosaic.utils.data_utils import AllocationType, MemoryUsage
from mosaic.libmosaic.utils.utils import get_printable_memory_event_set

# This is the snapshot file generated by scripts/generate_snapshot.py. Do not
# use any snapshots generated from real workloads as they may contain user data!
SNAPSHOT_FILE = "output.pickle"
EXPECTED_MEM_PEAK = 2255398132
EXPECTED_LOCAL_MEM_PEAK = 577984171
EXPECTED_LOCAL_MEM = 400913725
EXPECTED_TOTAL_ALLOC: int = EXPECTED_MEM_PEAK
EXPECTED_TOTAL_RESERVED = 0
EXPECTED_MAX_ALLOCATION_ADDRESS = "343e4b6023956"
EXPECTED_MEM_PEAK_LAST_ITER = 202846821
EXPECTED_MAX_ALLOCATION_ADDRESS_LAST_ITER = "231df1f389c4c"


def snapshot_path_str() -> str:
    snap_ref = importlib_resources.files(__package__).joinpath(
        "snapshots", SNAPSHOT_FILE
    )
    return str(snap_ref)


def output_ref() -> str:
    return importlib_resources.files(__package__).joinpath("outputs", "test_out.txt")


def snapshot_ref() -> object:
    return importlib_resources.files(__package__).joinpath("snapshots", SNAPSHOT_FILE)


class TestMemoryEndtoEndEntryPoints(TestCase):
    def setUp(self) -> None:
        super().setUp()

    def tearDown(self) -> None:
        super().tearDown()

    def test_get_memory_profile_happy_path(self) -> None:
        # Use the directory name as the module name
        PROFILE_TYPES = ["annotations", "categories"]
        for profile_type in PROFILE_TYPES:
            with tempfile.NamedTemporaryFile(
                suffix=".html", mode="w+", delete=True
            ) as output_file:
                memory_abstract = get_memory_profile(
                    snapshot=snapshot_path_str(),
                    out_path=output_file.name,
                    profile=profile_type,
                )
                self.assertEqual(
                    EXPECTED_TOTAL_ALLOC,
                    memory_abstract.memory_snapshot.max_memory_usage.total_alloc,
                )
                self.assertEqual(
                    EXPECTED_TOTAL_RESERVED,
                    memory_abstract.memory_snapshot.max_memory_usage.total_reserved,
                )

    def test_get_memory_profile_sad_path(self) -> None:
        # Use the directory name as the module name
        base_ref = str(importlib_resources.files(__package__))
        output_path = os.path.join(base_ref, "outputs", "test_memory_out.html")
        PROFILE_TYPES = ["fail"]
        try:
            for profile_type in PROFILE_TYPES:
                get_memory_profile(
                    snapshot=snapshot_path_str(),
                    out_path=output_path,
                    profile=profile_type,
                )
            self.assertFalse(True)
        except Exception:
            self.assertTrue(True)

    def test_get_memory_usage_by_annotation(self) -> None:
        # Test sub string case
        SUB_STRING_ANNOTATIONS = ("Annotation1", "Annotation2", "Annotation3")
        memory_usage_by_annotations = get_memory_usage_by_annotation_stage(
            snapshot=snapshot_path_str(),
            annotation=SUB_STRING_ANNOTATIONS,
            paste=False,
        )
        EXPECTED_NUM_ANNOTATIONS = 6
        self.assertEqual(EXPECTED_NUM_ANNOTATIONS, len(memory_usage_by_annotations))

        # Test invalid string case
        INVALID_STRING_ANNOTATION = "invalid_string"
        memory_usage_by_annotations = get_memory_usage_by_annotation_stage(
            snapshot=snapshot_path_str(),
            annotation=INVALID_STRING_ANNOTATION,
            paste=False,
        )
        EXPECTED_NUM_ANNOTATIONS = 0
        self.assertEqual(EXPECTED_NUM_ANNOTATIONS, len(memory_usage_by_annotations))

    def test_get_memory_usage_diff_same_trace(self) -> None:
        call_stack_diff = get_memory_usage_diff(
            snapshot_base=snapshot_path_str(),
            snapshot_diff=snapshot_path_str(),
            paste=False,
        )
        self.assertEqual(0, len(call_stack_diff))

    def test_get_memory_usage_peak(self) -> None:
        memory_usage_peak = get_memory_usage_peak(
            snapshot=snapshot_path_str(),
            trace="",
            allocation="",
            action="free",
            paste=False,
            print_stack=True,
            upload_result=False,
            start_time=None,
            end_time=None,
        )
        self.assertEqual(
            EXPECTED_MAX_ALLOCATION_ADDRESS,
            memory_usage_peak.memory_snapshot.max_allocation_info.addr,
        )
        self.assertEqual(
            EXPECTED_MEM_PEAK,
            memory_usage_peak.memory_snapshot.dynamic_memory_peak,
        )

    def test_get_memory_usage_peak_with_time_range(self) -> None:
        memory_usage_peak = get_memory_usage_peak(
            snapshot=snapshot_path_str(),
            trace="",
            allocation="",
            action="",
            paste=False,
            print_stack=False,
            upload_result=False,
            start_time=1759252605604106,
            end_time=1759252631649942,
        )
        self.assertEqual(
            EXPECTED_MEM_PEAK_LAST_ITER,
            memory_usage_peak.memory_snapshot.dynamic_memory_peak,
        )
        self.assertEqual(
            EXPECTED_MAX_ALLOCATION_ADDRESS_LAST_ITER,
            memory_usage_peak.memory_snapshot.max_allocation_info.addr,
        )

    def test_get_memory_usage(self) -> None:
        memory_usage = get_memory_usage(
            snapshot=snapshot_path_str(),
            trace="",
            allocation="2263c194bda7_0",
            action="free_completed",
            paste=False,
            print_stack=True,
        )
        # memory usage values
        EXPECTED_LOCAL_MEM_KEY = "free_completed: 2263c194bda7_0"
        EXPECTED_LOCAL_MEM_USAGE = 1783600757
        memory_usage_item = list(memory_usage.memory_snapshot.memory_usage.items())[0]
        memory_usage_item_key = memory_usage_item[0]
        memory_usage_item_value = memory_usage_item[1]
        self.assertEqual(EXPECTED_LOCAL_MEM_KEY, memory_usage_item_key)
        self.assertEqual(EXPECTED_LOCAL_MEM_USAGE, memory_usage_item_value)

        # invalid memory peak
        EXPECTED_MEM_PEAK_INVALID_VALUE = -1
        self.assertEqual(
            EXPECTED_MEM_PEAK_INVALID_VALUE,
            memory_usage.memory_snapshot.dynamic_memory_peak,
        )


class TestMemoryPeak(TestCase):
    def setUp(self) -> None:
        super().setUp()

    def tearDown(self) -> None:
        super().tearDown()

    def compare_string_to_file(self, mystr: str, filename: str) -> bool:
        """
        Compare a string to a text file.
        Args:
            string (str): The string to compare.
            filename (str): The name of the text file.
        Returns:
            bool: True if the string is equal to the file content, False otherwise.
        """
        try:
            with open(filename, "r") as file:
                file_content = file.read()
                return mystr == file_content
        except FileNotFoundError:
            print(f"File '{filename}' not found.")
            return False

    def test_peak_snapshot(self) -> None:
        # Use the directory name as the module name

        with importlib_resources.as_file(snapshot_ref()) as path:
            memory_abstract = MemoryAbstract(memory_snapshot_file=str(path))
            memory_abstract.load_memory_snapshot()
            memory_abstract.memory_snapshot.analyze_memory_snapshot("memory_peak")
            absolute_peak = get_printable_memory_event_set(
                memory_abstract.memory_snapshot.call_stack_hash_set
            )
            print(absolute_peak)
            self.assertEqual(
                EXPECTED_MEM_PEAK, memory_abstract.memory_snapshot.dynamic_memory_peak
            )
            with importlib_resources.as_file(output_ref()) as test_path:
                self.assertTrue(self.compare_string_to_file(absolute_peak, test_path))

            # Test local peak
            _ = memory_abstract.memory_snapshot.analyze_memory_snapshot(
                "memory_peak", allocation="32fa0599c7f59_0", action="free_completed"
            )

            self.assertEqual(
                EXPECTED_LOCAL_MEM_PEAK,
                memory_abstract.memory_snapshot.dynamic_memory_peak,
            )

            # Test local usage
            _ = memory_abstract.memory_snapshot.analyze_memory_snapshot(
                "memory_usage", allocation="32fa0599c7f59_0", action="free_completed"
            )

            self.assertEqual(
                EXPECTED_LOCAL_MEM,
                memory_abstract.memory_snapshot.memory_usage[
                    "free_completed: 32fa0599c7f59_0"
                ],
            )


class TestMemoryProfile(TestCase):
    def setUp(self) -> None:
        super().setUp()

    def tearDown(self) -> None:
        super().tearDown()

    def test_memory_profile_category(self) -> None:
        # Use the directory name as the module name
        with importlib_resources.as_file(snapshot_ref()) as path:
            memory_abstract = MemoryAbstract(memory_snapshot_file=str(path))
            memory_abstract.load_memory_snapshot()
            memory_abstract.memory_snapshot.analyze_memory_snapshot("alloc_history")
            peak = memory_abstract.memory_snapshot.max_memory_usage
            self.assertEqual(round(peak.total_alloc / 1024**3, 2), 2.1)
            self.assertEqual(peak.per_category_alloc_sum[AllocationType.PARAMETER], 0)
            self.assertEqual(peak.per_category_alloc_sum[AllocationType.ACTIVATION], 0)
            self.assertEqual(peak.per_category_alloc_sum[AllocationType.BACKWARD], 0)
            self.assertEqual(peak.per_category_alloc_sum[AllocationType.OPTIMIZER], 0)
            self.assertEqual(peak.per_category_alloc_sum[AllocationType.NET], 0)
            self.assertEqual(
                peak.per_category_alloc_sum[AllocationType.UNKNOWN], 2255398132.0
            )
            self.assertEqual(peak.per_category_alloc_sum[AllocationType.STATS], 0)
            self.assertEqual(peak.per_category_alloc_sum[AllocationType.FSDP], 0)

    def test_memory_profile_annotations(self) -> None:
        with importlib_resources.as_file(snapshot_ref()) as path:
            memory_abstract = MemoryAbstract(memory_snapshot_file=str(path))
            memory_abstract.load_memory_snapshot()
            memory_abstract.memory_snapshot.analyze_memory_snapshot(
                "alloc_history", profile_types=["annotations"]
            )
            peak = memory_abstract.memory_snapshot.max_memory_usage
            self.assertEqual(round(peak.total_alloc / 1024**3, 2), 2.1)
            self.assertEqual(peak.per_annotation_alloc_sum["Annotation1"], 2255398132.0)
            self.assertEqual(peak.per_annotation_alloc_sum["Annotation2"], 0.0)
            self.assertEqual(peak.per_annotation_alloc_sum["Annotation3"], 0.0)

    def test_memory_profile_compile_context(self) -> None:
        with importlib_resources.as_file(snapshot_ref()) as path:
            memory_abstract = MemoryAbstract(memory_snapshot_file=str(path))
            memory_abstract.load_memory_snapshot()
            memory_abstract.memory_snapshot.analyze_memory_snapshot(
                "alloc_history", profile_types=["compile_context"]
            )
            peak = memory_abstract.memory_snapshot.max_memory_usage
            self.assertEqual(round(peak.total_alloc / 1024**3, 2), 2.1)
            self.assertEqual(
                peak.per_compile_context_alloc_sum["context1"], 528274631.0
            )
            self.assertEqual(
                peak.per_compile_context_alloc_sum["context2"], 1212434191.0
            )
            self.assertEqual(
                peak.per_compile_context_alloc_sum["context3"], 514689310.0
            )

    def test_memory_profile_custom(self) -> None:
        """Test custom profiling functionality"""
        custom_rules = {
            "all_allocations": ".*",  # This should match all allocations in test data
            "specific_pattern": "nonexistent_pattern",  # This should match nothing
        }

        with importlib_resources.as_file(snapshot_ref()) as path:
            memory_abstract = MemoryAbstract(memory_snapshot_file=str(path))
            memory_abstract.load_memory_snapshot()
            memory_abstract.memory_snapshot.analyze_memory_snapshot(
                "alloc_history", profile_types=["custom"], custom_rules=custom_rules
            )
            peak = memory_abstract.memory_snapshot.max_memory_usage
            self.assertEqual(round(peak.total_alloc / 1024**3, 2), 2.1)

            if isinstance(peak, MemoryUsage):
                self.assertEqual(
                    peak.per_custom_alloc_sum["all_allocations"], 2255398132.0
                )
                self.assertEqual(peak.per_custom_alloc_sum["specific_pattern"], 0.0)

    def test_custom_profile_output_format(self) -> None:
        """Test that custom profile appears in string output"""
        custom_rules = {"test_category": ".*"}

        with importlib_resources.as_file(snapshot_ref()) as path:
            memory_abstract = MemoryAbstract(memory_snapshot_file=str(path))
            memory_abstract.load_memory_snapshot()
            memory_abstract.memory_snapshot.analyze_memory_snapshot(
                "alloc_history", profile_types=["custom"], custom_rules=custom_rules
            )
            peak = memory_abstract.memory_snapshot.max_memory_usage

            # Check that custom profile appears in the string representation
            peak_str = str(peak)
            self.assertIn("Custom Profile:", peak_str)
            self.assertIn("test_category:", peak_str)
            self.assertIn("2.1GiB", peak_str)  # Should show the memory amount
